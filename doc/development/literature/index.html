<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>literature</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" href="../../../style.css" type="text/css" />

<link rel="stylesheet" href="../../../local.css" type="text/css" />




<link rel="alternate" type="application/x-wiki" title="Edit this page" href="https://github.com/project-renard/project-renard.github.io/edit/source/doc/development/literature/index.tex" />



<link href="./tex4ht.css" rel="stylesheet" type="text/css" />



</head>
<body>

<div class="page">

<div class="pageheader">
<div class="header">
<span>
<span class="parentlinks">

<a href="../../../">Project Renard</a>/ 

<a href="../../">doc</a>/ 

<a href="../">development</a>/ 

</span>
<span class="title">
literature

</span>
</span>



</div>


<div class="actions">
<ul>

<li><a href="https://github.com/project-renard/project-renard.github.io/edit/source/doc/development/literature/index.tex" rel="nofollow">Edit</a></li>


<li><a href="../../../recentchanges/">RecentChanges</a></li>


<li><a href="https://github.com/project-renard/project-renard.github.io/commits/source/doc/development/literature/index.tex">History</a></li>







</ul>
</div>









</div>



<div class="sidebar">
<ul>
    <li><a href="../../../blog/">Blog</a></li>
    <li><a href="../../">Documentation</a></li>
    <ul>
        <li><a href="../../user/">User</a></li>
        <li><a href="../">Development</a></li>
        <ul>
            <li><a href="../meeting-log/">Development meeting log</a></li>
        </ul>
        <li><a href="../../survey/">Survey</a></li>
        <li><a href="../../design/">Design</a></li>
    </ul>
    <li><a href="../../../about/">About</a></li>
</ul>

</div>



<div id="pagebody">

<div id="content" role="main">
<body 
>
   <h3 class="sectionHead"><span class="titlemark">1   </span> <a 
 id="x1-10001"></a>Bret Victor</h3>
     <ul class="itemize1">
     <li class="itemize"><a 
href="http://worrydream.com/MediaForThinkingTheUnthinkable/note.html" class="url" ><span 
class="cmtt-10">http://worrydream.com/MediaForThinkingTheUnthinkable/note.html</span></a>
     </li>
     <li class="itemize"><a 
href="http://worrydream.com/MediaForThinkingTheUnthinkable/" class="url" ><span 
class="cmtt-10">http://worrydream.com/MediaForThinkingTheUnthinkable/</span></a>
     </li>
     <li class="itemize"><a 
href="http://worrydream.com/MagicInk/" class="url" ><span 
class="cmtt-10">http://worrydream.com/MagicInk/</span></a>
     </li>
     <li class="itemize"><a 
href="http://worrydream.com/TheHumaneRepresentationOfThought/note.html" class="url" ><span 
class="cmtt-10">http://worrydream.com/TheHumaneRepresentationOfThought/note.html</span></a>
     </li>
     <li class="itemize"><a 
href="http://vimeo.com/115154289" class="url" ><span 
class="cmtt-10">http://vimeo.com/115154289</span></a></li></ul>
<!--l. 159--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">2   </span> <a 
 id="x1-20002"></a>Alan Kay</h3>
<!--l. 161--><p class="noindent" ><a 
href="https://www.youtube.com/watch?v=YyIQKBzIuBY" class="url" ><span 
class="cmtt-10">https://www.youtube.com/watch?v=YyIQKBzIuBY</span></a>, <a 
href="http://www.tele-task.de/archive/video/flash/14029/" >HPI</a>
</p><!--l. 163--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">3   </span> <a 
 id="x1-30003"></a>Design of electronic books</h3>
<!--l. 165--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-40003"></a><a id="bibentry:marshall2009-reading"></a><span 
class="cmbx-10">Reading and Writing the Electronic Book</span><span 
class="cmbx-10"> </span><a 
href="#Xmarshall2009-reading"><span 
class="cmbx-10">Marshall</span></a><span 
class="cmbx-10"> (</span><a 
href="#Xmarshall2009-reading"><span 
class="cmbx-10">2009</span></a><span 
class="cmbx-10">)</span></span>
   <a href="#bibentry:marshall2009-reading">&para;</a>
</p>
<!--l. 167--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-50003"></a><a id="bibentry:pearson2013-digital-reading"></a><span 
class="cmbx-10">Designing for Digital Reading</span><span 
class="cmbx-10"> </span><a 
href="#Xpearson2013-digital-reading"><span 
class="cmbx-10">Pearson et</span><span 
class="cmbx-10"> al.</span></a><span 
class="cmbx-10"> (</span><a 
href="#Xpearson2013-digital-reading"><span 
class="cmbx-10">2013</span></a><span 
class="cmbx-10">)</span></span>
   <a href="#bibentry:pearson2013-digital-reading">&para;</a>
                                                                  

                                                                  
</p><!--l. 169--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">4   </span> <a 
 id="x1-60004"></a>Software engineering</h3>
<!--l. 171--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-70004"></a><a id="bibentry:rosenberg2008-dreaming-code"></a><span 
class="cmbx-10">Dreaming in code: two dozen programmers, three years, 4,732 bugs, and</span>
<span 
class="cmbx-10">one quest for transcendent software</span><span 
class="cmbx-10"> </span><a 
href="#Xrosenberg2008-dreaming-code"><span 
class="cmbx-10">Rosenberg</span></a><span 
class="cmbx-10"> (</span><a 
href="#Xrosenberg2008-dreaming-code"><span 
class="cmbx-10">2008</span></a><span 
class="cmbx-10">)</span></span>
   <a href="#bibentry:rosenberg2008-dreaming-code">&para;</a>
</p><!--l. 173--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">5   </span> <a 
 id="x1-80005"></a>Workﬂow</h3>
<!--l. 175--><p class="noindent" >In <a 
href="http://ahiddendiscourse.com/2013/02/17/the-cognitive-basis-for-academic-workflows/" >The cognitive basis for academic workﬂows</a>, Lisa D. Harper looks at sensemaking
models as a way to understand academic workﬂows.
</p><!--l. 179--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">6   </span> <a 
 id="x1-90006"></a>Scene graphs</h3>
<!--l. 181--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-100006"></a><a id="bibentry:tavenrath2016"></a><span 
class="cmbx-10">Handling Massive Transform Updates in a Scenegraph</span><span 
class="cmbx-10"> </span><a 
href="#Xtavenrath2016"><span 
class="cmbx-10">Tavenrath</span></a><span 
class="cmbx-10"> (</span><a 
href="#Xtavenrath2016"><span 
class="cmbx-10">2016</span></a><span 
class="cmbx-10">)</span></span>
   <a href="#bibentry:tavenrath2016">&para;</a>
</p>
     <ul class="itemize1">
     <li class="itemize">dynamic scene graph: many updates
     </li>
     <li class="itemize">extract just transform nodes to a transform tree</li></ul>
   <div class="par-math-display"><!--l. 189--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" ><mrow 
>
                             <msub><mrow 
><mi 
>T</mi></mrow><mrow 
><mn>2</mn><mo 
class="MathClass-punc">,</mo><mi 
>w</mi><mi 
>o</mi><mi 
>r</mi><mi 
>l</mi><mi 
>d</mi></mrow></msub 
> <mo 
class="MathClass-rel">=</mo> <msub><mrow 
><mi 
>T</mi></mrow><mrow 
><mn>2</mn><mo 
class="MathClass-punc">,</mo><mi 
>l</mi><mi 
>o</mi><mi 
>c</mi><mi 
>a</mi><mi 
>l</mi></mrow></msub 
> <mo 
class="MathClass-bin">&sdot;</mo> <msub><mrow 
><mi 
>T</mi></mrow><mrow 
><mn>0</mn><mo 
class="MathClass-punc">,</mo><mi 
>l</mi><mi 
>o</mi><mi 
>c</mi><mi 
>a</mi><mi 
>l</mi></mrow></msub 
> <mo 
class="MathClass-bin">&sdot;</mo> <msubsup><mrow 
><mi 
>T</mi></mrow><mrow 
><mi 
>l</mi><mi 
>o</mi><mi 
>c</mi><mi 
>a</mi><mi 
>l</mi></mrow><mrow 
><mo 
class="MathClass-bin">&lowast;</mo></mrow></msubsup 
>
</mrow></math></div>
                                                                  

                                                                  
<!--l. 189--><p class="nopar" >
</p><!--l. 191--><p class="indent" >   The world matrix is used for shader, culling, bounding box, collision
detection.
</p>
   <hr class="figure" /><div class="figure" 
>
                                                                  

                                                                  
<a 
 id="x1-100011"></a>
                                                                  

                                                                  
<!--l. 3--><p class="noindent" ><img 
src="tex4iki0y.png" alt="pict"  
 />
<br /> </p><div class="caption" 
><span class="id">Figure 1: </span><span  
class="content">Example tree</span></div><!--tex4ht:label?: x1-100011 -->
                                                                  

                                                                  
   </div><hr class="endfigure" />
<!--l. 200--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-110006"></a><a id="bibentry:worister2013lazy"></a><span 
class="cmbx-10">Lazy incremental computation for eﬃcient scene graph rendering</span><span 
class="cmbx-10"> </span><a 
href="#Xworister2013lazy"><span 
class="cmbx-10">W</span><span 
class="cmbx-10">ö</span><span 
class="cmbx-10">rister</span>
<span 
class="cmbx-10">et</span><span 
class="cmbx-10"> al.</span></a><span 
class="cmbx-10"> (</span><a 
href="#Xworister2013lazy"><span 
class="cmbx-10">2013</span></a><span 
class="cmbx-10">)</span></span>
   <a href="#bibentry:worister2013lazy">&para;</a>
</p>
     <ul class="itemize1">
     <li class="itemize"><span class="fbox">scene graph</span> creates <span class="fbox">dependency graph</span>
     </li>
     <li class="itemize"><span class="fbox">program</span> updates <span class="fbox">scene graph</span> updates<!--l. 204--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mo 
class="MathClass-bin">&lowast;</mo></math>
     <span class="fbox">dependency graph</span> <br 
class="newline" /><!--l. 206--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mo 
class="MathClass-bin">&lowast;</mo></math>
     but only parts that are visible are updated</li></ul>
<!--l. 209--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-120006"></a><span 
class="cmbx-10">Update algorithm</span></span>
</p>
<!--l. 211--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-130006"></a><a id="bibentry:reps1983incremental"></a><span 
class="cmbx-10">Incremental context-dependent analysis for language-based editors</span><span 
class="cmbx-10"> </span><a 
href="#Xreps1983incremental"><span 
class="cmbx-10">Reps</span>
<span 
class="cmbx-10">et</span><span 
class="cmbx-10"> al.</span></a><span 
class="cmbx-10"> (</span><a 
href="#Xreps1983incremental"><span 
class="cmbx-10">1983</span></a><span 
class="cmbx-10">)</span></span>
   <a href="#bibentry:reps1983incremental">&para;</a>
</p>
<!--l. 213--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-140006"></a><a id="bibentry:hudson1991incremental"></a><span 
class="cmbx-10">Incremental attribute evaluation: A ﬂexible algorithm for lazy</span>
<span 
class="cmbx-10">update</span><span 
class="cmbx-10"> </span><a 
href="#Xhudson1991incremental"><span 
class="cmbx-10">Hudson</span></a><span 
class="cmbx-10"> (</span><a 
href="#Xhudson1991incremental"><span 
class="cmbx-10">1991</span></a><span 
class="cmbx-10">)</span></span>
   <a href="#bibentry:hudson1991incremental">&para;</a>
</p><!--l. 215--><p class="indent" >   They use a semantic scene graph as in Separating semantics from rendering: a
scene graph based architecture for graphics applications <a 
href="#Xtobler2011separating">Tobler</a> (<a 
href="#Xtobler2011separating">2011</a>) — traversal
cost is high — caching eliminates this cost.
</p><!--l. 219--><p class="indent" >   caching however occurs an overhead (see Table 1 of paper) at startup
time
</p><!--l. 222--><p class="indent" >   need to benchmark the number of draw calls to see when it will pay oﬀ:
<!--l. 223--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>&uarr;</mi></mrow></math> draw
calls, <!--l. 223--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>&darr;</mi></mrow></math>
frame rate.
</p><!--l. 225--><p class="indent" >   can be parallelised
                                                                  

                                                                  
</p>
<!--l. 228--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-150006"></a><a id="bibentry:tobler2011separating"></a><span 
class="cmbx-10">Separating semantics from rendering: a scene graph based architecture for</span>
<span 
class="cmbx-10">graphics applications</span><span 
class="cmbx-10"> </span><a 
href="#Xtobler2011separating"><span 
class="cmbx-10">Tobler</span></a><span 
class="cmbx-10"> (</span><a 
href="#Xtobler2011separating"><span 
class="cmbx-10">2011</span></a><span 
class="cmbx-10">)</span></span>
   <a href="#bibentry:tobler2011separating">&para;</a>
</p><!--l. 230--><p class="indent" >   semantic graph is used to keep application state inside of graph
</p><!--l. 232--><p class="indent" >   application acts like a compiler
</p><!--l. 234--><p class="indent" >   semantic scene graph <!--l. 234--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mo 
class="MathClass-rel">&rarr;</mo></mrow></math>
rendering scene graph
</p><!--l. 236--><p class="indent" >   a single semantic scene graph node can build many intermediate rendering scene
graph nodes that diﬀer based on rendering backend
</p><!--l. 239--><p class="indent" >   applicator nodes are trees as well
</p><!--l. 241--><p class="indent" >   transformation </p>
     <ul class="itemize1">
     <li class="itemize">children: transformation matrices
     </li>
     <li class="itemize">aggregator: matrix multiplication</li></ul>
<!--l. 247--><p class="indent" >   LOD node: returns a diﬀerent scene graph based on level
</p><!--l. 249--><p class="indent" >   multiple-view has both: </p>
     <ul class="itemize1">
     <li class="itemize">shared data
     </li>
     <li class="itemize">private data</li></ul>
<!--l. 254--><p class="noindent" >for </p>
     <ul class="itemize1">
     <li class="itemize">traversal cache
     </li>
     <li class="itemize">traversal state</li></ul>
<!--l. 260--><p class="indent" >   editing of semantic nodes </p>
     <ul class="itemize1">
     <li class="itemize">back references
     </li>
     <li class="itemize">a little unclear why have 2 rendering scene graphs
         <ul class="itemize2">
         <li class="itemize">render normal
                                                                  

                                                                  
         <div class="verbatim" id="verbatim-1">
               ------
          <br />      |    |
          <br />      ------
</div>
         <!--l. 270--><p class="nopar" >
         </p></li>
         <li class="itemize">edit handles
                                                                  

                                                                  
         <div class="verbatim" id="verbatim-2">
               o    o
          <br />
          <br />      o    o
</div>
         <!--l. 276--><p class="nopar" >
         </p></li>
         <li class="itemize">render w/ edit handles
                                                                  

                                                                  
         <div class="verbatim" id="verbatim-3">
               o----o
          <br />      |    |
          <br />      o----o
</div>
         <!--l. 282--><p class="nopar" ></p></li></ul>
     </li></ul>
<!--l. 286--><p class="indent" >   rendering scene graph is cached by creating scene graph forest
</p>
<!--l. 289--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-160006"></a><a id="bibentry:zeleznik2000scene"></a><span 
class="cmbx-10">Scene-Graph-As-Bus: Collaboration between Heterogeneous Stand-alone</span>
<span 
class="cmbx-10">3-D Graphical Applications</span><span 
class="cmbx-10"> </span><a 
href="#Xzeleznik2000scene"><span 
class="cmbx-10">Zeleznik et</span><span 
class="cmbx-10"> al.</span></a><span 
class="cmbx-10"> (</span><a 
href="#Xzeleznik2000scene"><span 
class="cmbx-10">2000</span></a><span 
class="cmbx-10">)</span></span>
   <a href="#bibentry:zeleznik2000scene">&para;</a>
</p><!--l. 291--><p class="indent" >   networking
</p><!--l. 294--><p class="noindent" >
</p>
   <h4 class="likesubsectionHead"><a 
 id="x1-170006"></a>OpenSceneGraph</h4>
<!--l. 296--><p class="noindent" >TODO
</p><!--l. 298--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">7   </span> <a 
 id="x1-180007"></a>Attribute grammars</h3>
<!--l. 300--><p class="noindent" >Attribute grammars were ﬁrst introduced by Knuth. They consist of a normal
grammar, but augmented with attributes. Attributes are the results of calculations
based on the values and attributes of nodes in the parse tree. <a 
href="#Xknuth1968semantics">Knuth</a> (<a 
href="#Xknuth1968semantics">1968</a>).
</p><!--l. 305--><p class="indent" >   One issue with attributes grammars is determining the order of evaluation. One
naive approach is to use a topological sort based on the dependency graph of the
attributes.
</p>
   <div class="newtheorem">
<!--l. 309--><p class="noindent" ><span class="head">
<a 
 id="x1-18001r1"></a>
<span 
class="cmbx-10">Example 7.1.</span>  </span>Example: Attribute grammar for summing values in list. Taken
from <a 
href="#Xsteinlechner2019attrgrammars">Steinlechner et al.</a> (<a 
href="#Xsteinlechner2019attrgrammars">2019</a>).
</p><!--l. 313--><p class="indent" >   Data structure </p><!--l. 314-->
                                                                  

                                                                  
   <div class="lstlisting" id="listing-1"><span class="label"><a 
 id="x1-18002r1"></a></span>interface List <span 
class="cmsy-10">{</span> <span 
class="cmsy-10">}</span> <br /><span class="label"><a 
 id="x1-18003r2"></a></span>class Cons : List <span 
class="cmsy-10">{</span> <br /><span class="label"><a 
 id="x1-18004r3"></a></span>        Int Value; <br /><span class="label"><a 
 id="x1-18005r4"></a></span>        List Rest; <br /><span class="label"><a 
 id="x1-18006r5"></a></span><span 
class="cmsy-10">}</span> <br /><span class="label"><a 
 id="x1-18007r6"></a></span>class Nil : List <span 
class="cmsy-10">{</span> <span 
class="cmsy-10">}</span>
   
   </div>
<!--l. 323--><p class="indent" >   Attribute grammar (UUAGC syntax) </p><!--l. 324-->
   <div class="lstlisting" id="listing-2"><span class="label"><a 
 id="x1-18008r1"></a></span>syn SEM List <br /><span class="label"><a 
 id="x1-18009r2"></a></span><span 
class="cmsy-10">|</span> Nil  this.Sum = 0 <br /><span class="label"><a 
 id="x1-18010r3"></a></span><span 
class="cmsy-10">|</span> Cons this.Sum = this.Value + this.Rest.Sum
   
   </div>
   </div>
<!--l. 331--><p class="indent" >   In this example, the attribute grammar deﬁnes a <span 
class="cmti-10">synthesised attribute </span><span 
class="cmtt-10">Sum</span>. The
order of evaluation is bottom-up and since this grammar only uses a synthesised
attribute, it is an <span 
class="cmti-10">S-attributed grammar</span>.
</p><!--l. 336--><p class="indent" >   There are also special classes of attribute grammars than can be evaluated in a
single pass during parsing despite having both synthesised attributes and <span 
class="cmti-10">inherited</span>
<span 
class="cmti-10">attributes</span>.
</p><!--l. 340--><p class="indent" >   For a synthesised attribute <!--l. 340--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>&alpha;</mi></mrow></math>
and production <!--l. 340--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>S</mi> <mo 
class="MathClass-rel">&rarr;</mo> <mi 
>A</mi><mi 
>B</mi><mi 
>C</mi></mrow></math> the
semantic function for <!--l. 341--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>S</mi><mo 
class="MathClass-punc">.</mo><mi 
>&alpha;</mi></mrow></math> can
depend on attributes from <!--l. 342--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>A</mi></mrow></math>,
<!--l. 342--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>B</mi></mrow></math>, or
<!--l. 342--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>C</mi></mrow></math>.
</p><!--l. 344--><p class="indent" >   For the inherited attribute <!--l. 344--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>&beta;</mi></mrow></math>
on the same production, <!--l. 345--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>B</mi><mo 
class="MathClass-punc">.</mo><mi 
>&beta;</mi></mrow></math> can
depend on attributes from <!--l. 345--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>S</mi></mrow></math>,
<!--l. 345--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>A</mi></mrow></math>, or
<!--l. 345--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>C</mi></mrow></math>
(every other symbol).
</p><!--l. 348--><p class="indent" >   However, to evaluate a general class of attribute grammars, a speciﬁc traversal
would be needed for each attribute grammar depending on the dependencies for the
semantic functions. There existed algorithms that can take a speciﬁc attribute
grammar and compute a traversal function for an attribute. Some of these are
implemented in the for of a code generating compiler (e.g., UUAGC, JastAdd).
UUAGC which uses a version of the <a 
href="#Xkennedy1976automatic">Kennedy and Warren</a> (<a 
href="#Xkennedy1976automatic">1976</a>)) algorithm that is
described in <a 
href="#Xbransen2012kennedy">Bransen et al.</a> (<a 
href="#Xbransen2012kennedy">2012</a>).
</p><!--l. 358--><p class="indent" >   These algorithms are often used in an ahead of time compiler in order to generate
a static tree-walker evaluator. However, in some applications, an online version may
be useful for dynamic editing of values on the trees or changes to the tree structure
itself (e.g., a language editor). This merges the work in attribute grammars
with work in incremental computing <a 
href="#Xreps1983incremental">Reps et al.</a> (<a 
href="#Xreps1983incremental">1983</a>); <a 
href="#Xramalingam1993categorized">Ramalingam and
Reps</a> (<a 
href="#Xramalingam1993categorized">1993</a>).
</p><!--l. 366--><p class="indent" >   In order to use attribute grammars in a way that they can be composable (in FP,
AGs can be used to deﬁne catamorphisms compositionally) and easy to write,
there has been work on making embedded DSLs for AG deﬁnitions <a 
href="#Xsloane2010pure">Sloane
et al.</a> (<a 
href="#Xsloane2010pure">2010</a>).
                                                                  

                                                                  
</p><!--l. 372--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">8   </span> <a 
 id="x1-190008"></a>Incremental computing</h3>
<!--l. 374--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">9   </span> <a 
 id="x1-200009"></a>Self-adjusting computation</h3>
<!--l. 1--><p class="noindent" >
</p>
   <h3 class="likesectionHead"><a 
 id="x1-210009"></a>References</h3>
<!--l. 1--><p class="noindent" >
  </p><div class="thebibliography">
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xbransen2012kennedy"></a><span class="bibsp">   </span></span>Jeroen Bransen, Arie Middelkoop, Atze Dijkstra, and S Doaitse Swierstra. The
  kennedy-warren algorithm revisited: ordering attribute grammars. In <span 
class="cmti-10">International</span>
  <span 
class="cmti-10">Symposium on Practical Aspects of Declarative Languages</span>, pages 183–197.
  Springer, 2012. doi: 10.1007/978-<mstyle 
class="mbox"><mtext  >_</mtext></mstyle>3-<mstyle 
class="mbox"><mtext  >_</mtext></mstyle>642-<mstyle 
class="mbox"><mtext  >_</mtext></mstyle>27694-<mstyle 
class="mbox"><mtext  >_</mtext></mstyle>1<mstyle 
class="mbox"><mtext  >_</mtext></mstyle>14.
         </p><div class="quotation">
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract: </span>Attribute  Grammars  (AGs)  are  a  powerful  tool  for
      deﬁning an executable semantics of a programming language, and
      thus for implementing a compiler. An execution plan for an AG
      determines a static evaluation order for the attributes which are
      deﬁned  as  part  of  an  AG  speciﬁcation.  In  building  the  Utrecht
      Haskell Compiler (UHC), a large scale AG project, we discovered
      that the Ordered AG approach (Kastens, 1980) for building such
      plans becomes impractical: the additional dependencies between
      attributes introduced by this algorithm too often result in grammars
      for  which  no  execution  plan  can  be  generated.  To  avoid  such
      problems we have implemented a reﬁned version of the algorithm
      of Kennedy and Warren (1976) as part of our purely functional
      AG system and show how this algorithm solves the problems that
      surface with the Ordered AG approach. Furthermore, we present
      the results of applying this algorithm to the UHC code and show
      that this approach in some cases also has a positive eﬀect on the
      runtime of the resulting program.</p></div>
  <p class="bibitem-p" >URL <a 
href="http://dx.doi.org/10.1007/978-3-642-27694-1_14" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.1007/978-_3-_642-_27694-_1_14</span></a>.
  </p>
                                                                  

                                                                  
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xhudson1991incremental"></a><span class="bibsp">   </span></span>Scott E Hudson. Incremental attribute evaluation: A ﬂexible algorithm for lazy
  update. <span 
class="cmti-10">ACM Transactions on Programming Languages and Systems (TOPLAS)</span>,
  13(3):315–341, 1991. doi: 10.1145/117009.117012.
         </p><div class="quotation">
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract: </span>This paper introduces a new algorithm for incremental
      attribute evaluation. The algorithm is lazy: It evaluates only the
      attributes that are both aﬀected by a change and that are directly
      or  indirectly  observable  by  the  user.  In  this  way,  the  wasted
      work of computing values that are never actually used is avoided.
      Although the algorithm is not optimal, it performs better than the
      standard optimal algorithm in cases where expensive but optional
      computations need to be supported. Furthermore, the algorithm
      does not have some of the limitations of other algorithms. It works
      for general attributed graphs as well as for standard attributed
      trees. In addition, it does not presume any special editing model,
      and it supports multiple change points without loss of eﬃciency.</p></div>
  <p class="bibitem-p" >URL <a 
href="http://dx.doi.org/10.1145/117009.117012" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.1145/117009.117012</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xkennedy1976automatic"></a><span class="bibsp">   </span></span>Ken Kennedy and Scott K Warren. Automatic generation of eﬃcient evaluators
  for attribute grammars. In <span 
class="cmti-10">Proceedings of the 3rd ACM SIGACT-SIGPLAN</span>
  <span 
class="cmti-10">symposium on Principles on programming languages</span>, pages 32–49. ACM, 1976.
  doi: 10.1145/800168.811538.
         </p><div class="quotation">
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract: </span>The translation process may be divided into a syntactic
      phase and a semantic phase. Context-free grammars can be used
      to  describe  the  set  of  syntactically  correct  source  texts  in  a
      formal  yet  intuitively  appealing  way,  and  many  techniques  are
      now  known  for  automatically  constructing  parsers  from  given
      CF grammars. Knuth&#x2019;s attribute grammars oﬀer the prospect of
      similarly automating the implementation of the semantic phase.
      An attribute grammar is an ordinary CF grammar extended to
      specify the meaning of each string in the language. Each grammar
      symbol has an associated set of attributes:, and each production
      rule is provided with corresponding semantic rules expressing the
      relationships between the attributes of symbols in the production.
      To ﬁnd the meaning of a string, ﬁrst we ﬁnd its parse tree and then
      we determine the values of all the attributes of symbols in the tree.</p></div>
  <p class="bibitem-p" >URL <a 
href="http://dx.doi.org/10.1145/800168.811538" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.1145/800168.811538</span></a>.
  </p>
                                                                  

                                                                  
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xknuth1968semantics"></a><span class="bibsp">   </span></span>Donald E Knuth. Semantics of context-free languages. <span 
class="cmti-10">Mathematical systems</span>
  <span 
class="cmti-10">theory</span>, 2(2):127–145, 1968. doi: 10.1007/bf01692511.
         </p><div class="quotation">
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract: </span>Meaning may be assigned to a string in a context-free
      language  by  deﬁning  attributes  of  the  symbols  in  a  derivation
      tree for that string. The attributes can be deﬁned by functions
      associated  with  each  production  in  the  grammar.  This  paper
      examines  the  implications  of  this  process  when  some  of  the
      attributes are synthesized, i.e., deﬁned solely in terms of attributes
      of the descendants of the corresponding nonterminal symbol, while
      other attributes are inherited, i.e., deﬁned in terms of attributes
      of the ancestors of the nonterminal symbol. An algorithm is given
      which  detects  when  such  semantic  rules  could  possibly  lead  to
      circular  deﬁnition  of  some  attributes.  An  example  is  given  of  a
      simple  programming  language  deﬁned  with  both  inherited  and
      synthesized attributes, and the method of deﬁnition is compared to
      other techniques for formal speciﬁcation of semantics which have
      appeared in the literature.</p></div>
  <p class="bibitem-p" >URL <a 
href="http://dx.doi.org/10.1007/bf01692511" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.1007/bf01692511</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xmarshall2009-reading"></a><span class="bibsp">   </span></span>Catherine C. Marshall. <span 
class="cmti-10">Reading and Writing the Electronic Book</span>, volume 1.
  Morgan &#x0026; Claypool Publishers, 2009. doi: 10.2200/S00215ED1V01Y200907ICR009.
         </p><div class="quotation">
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract: </span>Developments over the last twenty years have fueled
      considerable  speculation  about  the  future  of  the  book  and  of
      reading itself. This book begins with a gloss over the history of
      electronic books, including the social and technical forces that have
      shaped their development. The focus then shifts to reading and
      how we interact with what we read: basic issues such as legibility,
      annotation,  and  navigation  are  examined  as  aspects  of  reading
      that  ebooks  inherit  from  their  print  legacy.  Because  reading  is
      fundamentally  communicative,  I  also  take  a  closer  look  at  the
      sociality of reading: how we read in a group and how we share what
      we read. Studies of reading and ebook use are integrated throughout
      the book, but Chapter 5 “goes meta” to explore how a researcher
      might go about designing his or her own reading-related studies.
      No book about ebooks is complete without an explicit discussion of
      content preparation, i.e., how the electronic book is written. Hence,
      Chapter 6 delves into the underlying representation of ebooks and
      eﬀorts to create and apply markup standards to them. This chapter
                                                                  

                                                                  
      also examines how print genres have made the journey to digital
      and how some emerging digital genres might be realized as ebooks.
      Finally, Chapter 7 discusses some beyond-the-book functionality:
      how can ebook platforms be transformed into portable personal
      libraries?  In  the  end,  my  hope  is  that  by  the  time  the  reader
      reaches the end of this book, he or she will feel equipped to perform
      the next set of studies, write the next set of articles, invent new
      ebook functionality, or simply engage in a heated argument with the
      stranger in seat 17C about the future of reading. Table of Contents:
      Preface / Figure Credits / Introduction / Reading / Interaction
      / Reading as a Social Activity / Studying Reading / Beyond the
      Book / References / Author Biography</p></div>
  <p class="bibitem-p" >URL <a 
href="http://dx.doi.org/10.2200/S00215ED1V01Y200907ICR009" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.2200/S00215ED1V01Y200907ICR009</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xpearson2013-digital-reading"></a><span class="bibsp">   </span></span>Jennifer Pearson, George Buchanan, and Harold Thimbleby. <span 
class="cmti-10">Designing for</span>
  <span 
class="cmti-10">Digital Reading</span>, volume 5.  Morgan &#x0026; Claypool Publishers, 2013.  doi:
  10.2200/S00539ED1V01Y201310ICR029.
         </p><div class="quotation">
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract: </span>Reading is a complex human activity that has evolved,
      and  co-evolved,  with  technology  over  thousands  of  years.  Mass
      printing in the ﬁfteenth century ﬁrmly established what we know
      as the modern book, with its physical format of covers and paper
      pages, and now-standard features such as page numbers, footnotes,
      and diagrams. Today, electronic documents are enabling paperless
      reading supported by eReading technologies such as Kindles and
      Nooks, yet a high proportion of users still opt to print on paper
      before reading. This persistent habit of “printing to read” is one
      sign  of  the  shortcomings  of  digital  documents  –  although  the
      popularity of eReaders is one sign of the shortcomings of paper.
      How do we get the best of both worlds? The physical properties
      of paper (for example, it is light, thin, and ﬂexible) contribute to
      the ease with which physical documents are manipulated; but these
      properties have a completely diﬀerent set of aﬀordances to their
      digital equivalents. Paper can be folded, ripped, or scribbled on
      almost subconsciously – activities that require signiﬁcant cognitive
      attention  in  their  digital  form,  if  they  are  even  possible.  The
      nearly  subliminal  interaction  that  comes  from  years  of  learned
      behavior with paper has been described as lightweight interaction,
      which  is  achieved  when  a  person  actively  reads  an  article  in  a
      way  that  is  so  easy  and  unselfconscious  that  they  are  not  apt
      to  remember  their  actions  later.  Reading  is  now  in  a  period  of
      rapid change, and digital text is fast becoming the predominant
                                                                  

                                                                  
      mode  of  reading.  As  a  society,  we  are  merely  at  the  start  of
      the journey of designing truly eﬀective tools for handling digital
      text.  This  book  investigates  the  advantages  of  paper,  how  the
      aﬀordances  of  paper  can  be  realized  in  digital  form,  and  what
      forms best support lightweight interaction for active reading. To
      understand how to design for the future, we review the ways reading
      technology and reader behavior have both changed and remained
      constant over hundreds of years. We explore the reasoning behind
      reader behavior and introduce and evaluate several user interface
      designs that implement these lightweight properties familiar from
      our everyday use of paper. We start by looking back, reviewing the
      development of reading technology and the progress of research on
      reading over many years. Drawing key concepts from this review,
      we move forward to develop and test methods for creating new and
      more eﬀective interactions for supporting digital reading. Finally,
      we  lay  down  a  set  of  lightweight  attributes  which  can  be  used
      as  evidence-based  guidelines  to  improve  the  usability  of  future
      digital  reading  technologies.  By  the  end  of  this  book,  then,  we
      hope you will be equipped to critique the present state of digital
      reading, and to better design and evaluate new interaction styles
      and technologies. Table of Contents: Preface / Acknowledgments /
      Figure Credits / Introduction / Reading Through the Ages / Key
      Concepts / Lightweight Interactions / Improving Digital Reading
      / Bibliography / Authors&#x2019; Biographies</p></div>
  <p class="bibitem-p" >URL <a 
href="http://dx.doi.org/10.2200/S00539ED1V01Y201310ICR029" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.2200/S00539ED1V01Y201310ICR029</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xramalingam1993categorized"></a><span class="bibsp">   </span></span>Ganesan Ramalingam and Thomas Reps. A categorized bibliography on
  incremental computation. In <span 
class="cmti-10">Proceedings of the 20th ACM SIGPLAN-SIGACT</span>
  <span 
class="cmti-10">symposium on Principles of programming languages</span>, pages 502–510. ACM, 1993.
  doi: 10.1145/158511.158710. URL <a 
href="http://dx.doi.org/10.1145/158511.158710" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.1145/158511.158710</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xreps1983incremental"></a><span class="bibsp">   </span></span>Thomas Reps, Tim Teitelbaum, and Alan Demers. Incremental context-dependent
  analysis for language-based editors. <span 
class="cmti-10">ACM Transactions on Programming</span>
  <span 
class="cmti-10">Languages and Systems (TOPLAS)</span>, 5(3):449–477, 1983. doi: 10.1145/2166.357218.
         </p><div class="quotation">
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract:  </span>Knowledge  of  a  programming  language&#x2019;s  grammar
      allows language-based editors to enforce syntactic correctness at
      all times during development by restricting editing operations to
      legitimate modiﬁcations of the program&#x2019;s context-free derivation
      tree; however, not all language constraints can be enforced in this
      way because not all features can be described by the context-free
                                                                  

                                                                  
      formalism. Attribute grammars permit context-dependent language
      features  to  be  expressed  in  a  modular,  declarative  fashion  and
      thus are a good basis for specifying language-based editors. Such
      editors represent programs as attributed trees, Which are modiﬁed
      by operations such as subtree pruning and grafting. Incremental
      analysis  is  performed  by  updating  attribute  values  after  every
      modiﬁcation. This paper discusses how updating can be carried out
      and presents several algorithms for the task, including one that is
      asymptotically optimal in time.</p></div>
  <p class="bibitem-p" >URL <a 
href="http://dx.doi.org/10.1145/2166.357218" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.1145/2166.357218</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xrosenberg2008-dreaming-code"></a><span class="bibsp">   </span></span>Scott Rosenberg. <span 
class="cmti-10">Dreaming in code: two dozen programmers, three years, 4,732</span>
  <span 
class="cmti-10">bugs, and one quest for transcendent software</span>. Three Rivers Press (CA), 2008.
  ISBN 978-1-400-08246-9.
         </p><div class="quotation">
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract:  </span>Our  civilization  runs  on  software.  Yet  the  art  of
      creating it continues to be a dark mystery, even to the experts.
      To ﬁnd out why its so hard to bend computers to our will, Scott
      Rosenberg spent three years following a team of maverick software
      developersled by Lotus 1-2-3 creator Mitch Kapordesigning a novel
      personal information manager meant to challenge market leader
      Microsoft Outlook. Their story takes us through a maze of abrupt
      dead ends and exhilarating breakthroughs as they wrestle not only
      with the abstraction of code, but with the unpredictability of human
      behaviorespecially their own.</p></div>
  <p class="bibitem-p" >URL <a 
href="http://www.dreamingincode.com/" class="url" ><span 
class="cmtt-10">http://www.dreamingincode.com/</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xsloane2010pure"></a><span class="bibsp">   </span></span>Anthony M Sloane, Lennart CL Kats, and Eelco Visser. A pure object-oriented
  embedding of attribute grammars. <span 
class="cmti-10">Electronic Notes in Theoretical Computer</span>
  <span 
class="cmti-10">Science</span>, 253(7):205–219, 2010. doi: 10.1016/j.entcs.2010.08.043.
         </p><div class="quotation">
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract:  </span>Attribute  grammars  are  a  powerful  speciﬁcation
      paradigm for many language processing tasks, particularly semantic
      analysis  of  programming  languages.  Recent  attribute  grammar
      systems use dynamic scheduling algorithms to evaluate attributes
      by  need.  In  this  paper,  we  show  how  to  remove  the  need  for
      a  generator,  by  embedding  a  dynamic  approach  in  a  modern,
      object-oriented  programming  language  to  implement  a  small,
      lightweight  attribute  grammar  library.  The  Kiama  attribution
                                                                  

                                                                  
      library has similar features to current generators, including cached,
      uncached,  circular,  higher-order  and  parameterised  attributes,
      and  implements  new  techniques  for  dynamic  extension  and
      variation of attribute equations. We use the Scala programming
      language  because  of  its  combination  of  object-oriented  and
      functional  features,  support  for  domain-speciﬁc  notations  and
      emphasis on scalability. Unlike generators with specialised notation,
      Kiama  attribute  grammars  use  standard  Scala  notations  such
      as  pattern-matching  functions  for  equations  and  mixins  for
      composition. A performance analysis shows that our approach is
      practical for realistic language processing.</p></div>
  <p class="bibitem-p" >URL <a 
href="http://dx.doi.org/10.1016/j.entcs.2010.08.043" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.1016/j.entcs.2010.08.043</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xsteinlechner2019attrgrammars"></a><span class="bibsp">   </span></span>Harald Steinlechner, Georg Haaser, Stefan Maierhofer, and Robert Tobler.
  Attribute grammars for incremental scene graph rendering. pages 77–88.
  SCITEPRESS - Science and Technology Publications, 02 2019.  ISBN
  9789897583544. doi: 10.5220/0007372800770088.
         </p><div class="quotation">
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract: </span>Scene graphs, as found in many visualization systems
      are  a  well-established  concept  for  modeling  virtual  scenes  in
      computer  graphics.  State-of-the-art  approaches  typically  issue
      appropriate draw commands while traversing the graph. Equipped
      with  a  functional  programming  mindset  we  take  a  diﬀerent
      approach and utilize attribute grammars as a central concept for
      modeling the problem domain declaratively. Instead of issuing draw
      commands imperatively, we synthesize ﬁrst class objects describing
      appropriate  draw  commands.  In  order  to  make  this  approach
      practical  in  the  face  of  dynamic  changes  to  the  scene  graph,
      we  utilize  incremental  evaluation,  and  thereby  avoid  repeated
      evaluation  of  unchanged  parts.  Our  application  prototypically
      demonstrates how complex systems beneﬁt from domain-speciﬁc
      languages,  declarative  problem  solving  and  the  implications
      thereof. Besides from being concise and expressive, our solution
      demonstrates a real-world use case of self-adjusting computation
      which  elegantly  extends  scene  graphs  with  well-deﬁned  reactive
      semantics and eﬃcient, incremental execution.</p></div>
  <p class="bibitem-p" >URL <a 
href="http://dx.doi.org/10.5220/0007372800770088" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.5220/0007372800770088</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xtavenrath2016"></a><span class="bibsp">   </span></span>Markus Tavenrath. Handling massive transform updates in a scenegraph, mar 2016. URL
  <a 
href="http://on-demand.gputechconf.com/gtc/2016/presentation/s6131-tavenrath-scenegraph.pdf" class="url" ><span 
class="cmtt-10">http://on-_demand.gputechconf.com/gtc/2016/presentation/s6131-_tavenrath-_scenegraph.pdf</span></a>.
                                                                  

                                                                  
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xtobler2011separating"></a><span class="bibsp">   </span></span>Robert F Tobler. Separating semantics from rendering: a scene graph based
  architecture for graphics applications. <span 
class="cmti-10">The Visual Computer</span>, 27(6-8):687–695,
  2011. doi: 10.1007/s00371-<mstyle 
class="mbox"><mtext  >_</mtext></mstyle>011-<mstyle 
class="mbox"><mtext  >_</mtext></mstyle>0572-<mstyle 
class="mbox"><mtext  >_</mtext></mstyle>0.
         </p><div class="quotation">
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract: </span>A large number of rendering and graphics applications
      developed  in  research  and  industry  are  based  on  scene  graphs.
      Traditionally, scene graphs encapsulate the hierarchical structure
      of a complete 3D scene, and combine both semantic and rendering
      aspects. In this paper, we propose a clean separation of the semantic
      and rendering parts of the scene graph. This leads to a generally
      applicable  architecture  for  graphics  applications  that  is  loosely
      based  on  the  well-known  Model-View-Controller  (MVC)  design
      pattern for separating the user interface and computation parts
      of an application. We explore the beneﬁts of this new design for
      various rendering and modeling tasks, such as rendering dynamic
      scenes, out-of-core rendering of large scenes, generation of geometry
      for trees and vegetation, and multi-view rendering. Finally, we show
      some of the implementation details that have been solved in the
      process of using this software architecture in a large framework for
      rapid development of visualization and rendering applications.</p></div>
  <p class="bibitem-p" >URL <a 
href="http://dx.doi.org/10.1007/s00371-011-0572-0" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.1007/s00371-_011-_0572-_0</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xworister2013lazy"></a><span class="bibsp">   </span></span>Michael Wörister, Harald Steinlechner, Stefan Maierhofer, and Robert F Tobler.
  Lazy incremental computation for eﬃcient scene graph rendering. In <span 
class="cmti-10">Proceedings of</span>
  <span 
class="cmti-10">the 5th high-performance graphics conference</span>, pages 53–62. ACM, 2013. doi:
  10.1145/2492045.2492051.
         </p><div class="quotation">
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract:  </span>In  order  to  provide  a  highly  performant  rendering
      system while maintaining a scene graph structure with a high level
      of abstraction, we introduce improved rendering caches, that can
      be updated incrementally without any scene graph traversal. The
      basis of this novel system is the use of a dependency graph, that
      can be synthesized from the scene graph and links all sources of
      changes to the aﬀected parts of rendering caches. By using and
      extending concepts from incremental computation we minimize the
      computational overhead for performing the necessary updates due
      to  changes  in  any  inputs.  This  makes  it  possible  to  provide  a
      high-level semantic scene graph, while retaining the opportunity to
      apply a number of known optimizations to the rendering caches
                                                                  

                                                                  
      even for dynamic scenes. Our evaluation shows that the resulting
      rendering system is highly competitive and provides good rendering
      performance for scenes ranging from completely static geometry all
      the way to completely dynamic geometry.</p></div>
  <p class="bibitem-p" >URL <a 
href="http://dx.doi.org/10.1145/2492045.2492051" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.1145/2492045.2492051</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xzeleznik2000scene"></a><span class="bibsp">   </span></span>Bob Zeleznik, Loring Holden, Michael Capps, Howard Abrams, and Tim Miller.
  Scene-graph-as-bus: Collaboration between heterogeneous stand-alone 3-d
  graphical applications. In <span 
class="cmti-10">Computer Graphics Forum</span>, volume 19, pages 91–98.
  Wiley Online Library, 2000. doi: 10.1111/1467-<mstyle 
class="mbox"><mtext  >_</mtext></mstyle>8659.00401.
         </p><div class="quotation">
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract: </span>We describe the SceneGraphAsBus technique (SGAB),
      the  ﬁrst  step  in  a  staircase  of  solutions  for  sharing  software
      components for virtual environments. The goals of SGAB are to
      allow, with minimal eﬀort, independentlydesigned applications to
      share  component  functionality;  and  for  multiple  users  to  share
      applications  designed  for  single  users.This  paper  reports  on  the
      SGAB  design  for  transparently  conjoining  diﬀerent  applications
      by unifying the state information contained in their scene graphs.
      SGAB  monitors  and  maps  changes  in  the  local  scene  graph  of
      one  application  to  a  neutral  scene  graph  representation  (NSG),
      distributes  the  NSG  changes  over  the  network  to  remote  peer
      applications, and then maps the NSG changes to the local scene
      graph  of  the  remote  application.  The  fundamental  contribution
      of  SGAB  is  that  both  the  local  and  remote  applications  can
      be completely unaware of each other; that is, both applications
      can interoperate without code or binary modiﬁcation despite each
      having no knowledge of networking or interoperability.</p></div>
  <p class="bibitem-p" >URL <a 
href="http://dx.doi.org/10.1111/1467-8659.00401" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.1111/1467-_8659.00401</span></a>.
</p>
  </div>
    

</div>







</div>

<div id="footer" class="pagefooter" role="contentinfo">

<div id="pageinfo">












<div class="pagedate">
Last edited <span class="date">Sat 12 Sep 2020 09:34:10 PM UTC</span>
<!-- Created <span class="date">Sun 04 Nov 2018 07:46:35 AM UTC</span> -->
</div>

</div>


<!-- from Project Renard -->
</div>

</div>

</body>
</html>
